Plain Daffodil Dove

High

# Colecting Protocol Fees after claming period leads to fees lost

### Summary

The Protocol fee calculation happens over the reserve amount of tokens, which means, the more the merrier. That is the expected behavior for this type of mechanism. However, the `claimFee` process is not enforced before an auction ends. This means, if the fee is claimed after an auction it will account for less `reserveTokens` than before. Reducing Protocol income.

The `Pool::claimFee` function calculates the `feeAmount` using the `getFeeAmount` internal function to calculate the `amount of fees` over the `amount of reserveTokens`. It is not enforced before the auction ends, which means that when it is done after, it will consider fewer reserve tokens and provide the wrong fee amount.

It is also inconsistent the collection as it can happen during a call to `setFee`.

### Root Cause

Lack of flow definition to fee collection.
1. Calling before an Auction ends, can be too high for users to pay.
2. Calling after can be too low for protocol sustainability.

https://github.com/sherlock-audit/2024-12-plaza-finance/blob/main/plaza-evm/src/Pool.sol#L700-L712

I asked for information about the flow on Discord but didn't receive any answer until the moment of this issue. Anyways, both scenarios can damage protocol or users.

### Internal Pre-conditions

While an Auction is ongoing: higher fees
After an Auction ends: fewer fees.

### External Pre-conditions

None.

### Attack Path

Beneficiary or an "allowed role" calls `claimFees`.

### Impact

Scenario 1
- Protocol will lose fees as the amount of `reserveTokens` goes down when calling `endAuction` and the calculations account for `reserveTokens` on the contract to get the fee amount.

Scenario 2
- Users are overcharged because the Protocol calls `claimFee` before an Auction ends, and calculations account for the total `reserveToken` on the contract while it should consider only the amount after an Auction ends.

There are no constraints, which leads to double impact depending on how you look at it.

### PoC

I am considering a small number of coupons, and even small amounts can impact the calculations. Bigger amounts will generate bigger losses.

Call `test_claimFeesBeforeAuction` and then call `test_claimFeesAfterAuction` to compare results.

Forked Helper

<details>

```solidity

//SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import { Test, console } from "forge-std/Test.sol";

///Protocol Contracts
import { Auction } from "../../src/Auction.sol";
import { BalancerOracleAdapter } from "../../src/BalancerOracleAdapter.sol";
import { BalancerRouter } from "../../src/BalancerRouter.sol";
import { BondOracleAdapter } from "../../src/BondOracleAdapter.sol";
import { BondToken } from "../../src/BondToken.sol";
import { Deployer } from "../../src/utils/Deployer.sol";
import { Distributor } from "../../src/Distributor.sol";
import { LeverageToken } from "../../src/LeverageToken.sol";
import { OracleFeeds } from "../../src/OracleFeeds.sol";
import { OracleReader } from "../../src/OracleReader.sol";
import { Pool } from "../../src/Pool.sol";
import { PoolFactory } from "../../src/PoolFactory.sol";
import { PreDeposit } from "../../src/PreDeposit.sol";

///OpenZeppelin Contracts
import { ERC1967Proxy } from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import { UpgradeableBeacon } from "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol";
import { BeaconProxy } from "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IWETH {
    function deposit() external payable;
}

contract Helper is Test {
    //Fork Variables
    uint256 s_baseFork;
    string BASE_RPC = vm.envString("BASE_RPC");

    //Protocol Tokens
    IERC20 constant wETH = IERC20(0x4200000000000000000000000000000000000006);
    IERC20 constant USDC = IERC20(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913);
    address constant CL_ETH_PRICE_FEED = 0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70;
    address constant BALANCER_VAULT = address(0x0);
    address constant BALANCER_POOL_TOKENS = address(0x0);

    //DUMMY DEPLOYER
    PoolFactory s_dummyFactory;
    Auction s_dummyAuction;
    PreDeposit s_dummyPre;
    BondToken s_dummyBond;
    LeverageToken s_dummyLev;
    Pool s_dummyPool;
    Distributor s_dummyDistributor;

    //Protocol Contracts
    Auction s_auction;
    BalancerOracleAdapter s_balancerOracle;
    BalancerRouter s_balancerRouter;
    BondOracleAdapter s_bondAdapter;
    BondToken s_bond;
    Deployer s_deployer;
    Distributor s_distributor;
    LeverageToken s_lev;
    OracleFeeds s_feeds;
    OracleReader s_reader;
    Pool s_pool;
    PoolFactory s_factory;
    PreDeposit s_pre;

    //Protocol Base Proxy Contracts
    ERC1967Proxy s_factoryProxy;
    ERC1967Proxy s_auctionProxy;
    ERC1967Proxy s_preProxy;
    UpgradeableBeacon s_poolProxy;
    UpgradeableBeacon s_bondProxy;
    UpgradeableBeacon s_levProxy;
    UpgradeableBeacon s_distributorProxy;

    //Wrappers
    PoolFactory s_factoryWrapper;
    Auction s_auctionWrapper;
    PreDeposit s_preWrapper;
    Pool s_poolWrapper;
    BondToken s_bondWrapper;
    LeverageToken s_levWrapper;
    Distributor s_distributorWrapper;

    //Types
    Pool.TokenType types;

    //Fake Roles Variables
    address s_governanceRole = makeAddr("GOV_ROLE");
    address s_minterRole = makeAddr("MINTER_ROLE");
    address s_securityRole = makeAddr("SECURITY_COUNCIL_ROLE");
    address s_poolRole = makeAddr("POOL_ROLE");

    //Actors
    address s_coinbase = address(0x739120AdE7ED878FcA5bbDB806263a8258FE2360);
    address s_owner = makeAddr("s_owner");
    address s_beneficiary = makeAddr("s_beneficiary");
    address s_user01 = makeAddr("s_user01");
    address s_user02 = makeAddr("s_user02");
    address s_user03 = makeAddr("s_user03");
    address s_user04 = makeAddr("s_user04");

    //Utils
    uint256 constant USDC_INITIAL_AMOUNT = 100_000*10**6;
    uint256 constant WETH_INITIAL_AMOUNT = 100*10**18;
    uint256 constant RESERVE_INITIAL_AMOUNT = 10*10**18;
    uint256 constant BOND_AMOUNT = 10*10**18;
    uint256 constant LEV_AMOUNT = 10*10**18;
    uint256 constant AMOUNT_TO_DEPOSIT_ON_CREATE = 10*10**18;

    ///Events
    event AuctionEnded(Auction.State state, uint256 totalSellReserveAmount, uint256 totalBuyCouponAmount);


    function setUp() public {
        //Start Fork
        s_baseFork = vm.createFork(BASE_RPC);
        vm.selectFork(s_baseFork);

        //DUMMY DEPLOYER
        s_dummyFactory = new PoolFactory();
        s_dummyAuction = new Auction();
        s_dummyPre = new PreDeposit();
        s_dummyBond = new BondToken();
        s_dummyLev = new LeverageToken();
        s_dummyDistributor = new Distributor();
        s_dummyPool = new Pool();

        //Deploy Proxies
        s_factoryProxy = new ERC1967Proxy(address(s_dummyFactory), bytes(""));
        s_auctionProxy = new ERC1967Proxy(address(s_dummyAuction), bytes(""));
        s_preProxy = new ERC1967Proxy(address(s_dummyPre), bytes(""));
        s_bondProxy = new UpgradeableBeacon(address(s_dummyBond), s_owner);
        s_levProxy = new UpgradeableBeacon(address(s_dummyLev), s_owner);
        s_poolProxy = new UpgradeableBeacon(address(s_dummyPool), s_owner);
        s_distributorProxy = new UpgradeableBeacon(address(s_dummyDistributor), s_owner);

        //Wrap Proxies with Implementations
        s_factoryWrapper = PoolFactory(address(s_factoryProxy));
        s_auctionWrapper = Auction(address(s_auctionProxy));
        s_preWrapper = PreDeposit(address(s_preProxy));
        s_poolWrapper = Pool(address(s_poolProxy));

        //Deploy Contracts
        //1.
        s_deployer = new Deployer();
        //2.
        vm.startPrank(s_governanceRole); //Oracle Feeds
            s_feeds = new OracleFeeds();
            s_feeds.setPriceFeed(
                address(wETH),
                address(0), //Following Docs, it means == USD
                CL_ETH_PRICE_FEED,
                86400
            );
        vm.stopPrank();
        //3.
        s_pool = new Pool();
        //4.
        s_factory = new PoolFactory();
        //5.
        s_distributor = new Distributor();
        //6.
        vm.startPrank(s_governanceRole); //Init & Upgrade Factory
            s_factoryWrapper.initialize(
                s_governanceRole,
                address(s_deployer),
                address(s_feeds),
                address(s_poolProxy),
                address(s_bondProxy),
                address(s_levProxy),
                address(s_distributorProxy)
            );
            //7.
            s_factoryWrapper.upgradeToAndCall(address(s_factory), bytes(""));
        vm.stopPrank();
        
        //Deployed by Factory
        // - deployer
        // - s_bond
        // - s_lev
        // - distributor

        //Deployed by Pool
        // - s_auction;
        s_balancerOracle = new BalancerOracleAdapter();
        s_balancerRouter = new BalancerRouter(
            BALANCER_VAULT,
            BALANCER_POOL_TOKENS
        );
        s_bondAdapter = new BondOracleAdapter();
        s_reader = new OracleReader();
        s_pre = new PreDeposit();

        vm.startPrank(address(s_coinbase));
        USDC.transfer(s_user01, USDC_INITIAL_AMOUNT);
        USDC.transfer(s_user02, USDC_INITIAL_AMOUNT);
        USDC.transfer(s_user03, USDC_INITIAL_AMOUNT);
        USDC.transfer(s_user04, USDC_INITIAL_AMOUNT);
        vm.stopPrank();

        console.log(wETH.balanceOf(address(wETH)));

        vm.deal(s_governanceRole, WETH_INITIAL_AMOUNT);
        vm.deal(s_user01, WETH_INITIAL_AMOUNT);
        vm.deal(s_user02, WETH_INITIAL_AMOUNT);
        vm.deal(s_user03, WETH_INITIAL_AMOUNT);
        vm.deal(s_user04, WETH_INITIAL_AMOUNT);

        vm.prank(s_governanceRole);
        IWETH(address(wETH)).deposit{value: WETH_INITIAL_AMOUNT}();
        vm.prank(s_user01);
        IWETH(address(wETH)).deposit{value: WETH_INITIAL_AMOUNT}();
        vm.prank(s_user02);
        IWETH(address(wETH)).deposit{value: WETH_INITIAL_AMOUNT}();
        vm.prank(s_user03);
        IWETH(address(wETH)).deposit{value: WETH_INITIAL_AMOUNT}();
        vm.prank(s_user04);
        IWETH(address(wETH)).deposit{value: WETH_INITIAL_AMOUNT}();

        vm.startPrank(s_governanceRole);
        s_factoryWrapper.grantRole(s_factory.POOL_ROLE(), s_governanceRole);
        vm.stopPrank();

        //Create the pool
        helper_createPool();

        //Upgrade Proxy
        vm.prank(s_owner);
        s_poolProxy.upgradeTo(address(s_pool));
    }

    function helper_createPool() public {
        PoolFactory.PoolParams memory params = PoolFactory.PoolParams({
            fee: 100000,
            reserveToken: address(wETH),
            couponToken: address(USDC),
            distributionPeriod: 90 days,
            sharesPerToken: 10*10**6, //Shares have 10**6 decimals
            feeBeneficiary: s_beneficiary
        });

        vm.startPrank(s_governanceRole);
        //1.
        wETH.approve(address(s_factoryWrapper), WETH_INITIAL_AMOUNT);
        //2.
        s_poolWrapper = Pool(s_factoryWrapper.createPool(
            params,
            RESERVE_INITIAL_AMOUNT,
            BOND_AMOUNT,
            LEV_AMOUNT,
            "BondToken",
            "BTN",
            "LeverageToken",
            "LEVT",
            false
        ));

        s_poolWrapper.setAuctionPeriod(10 days);

        vm.stopPrank();

        s_bondWrapper = BondToken(address(s_poolWrapper.bondToken()));
        s_levWrapper = LeverageToken(address(s_poolWrapper.lToken()));
        s_distributorWrapper  = Distributor(s_factoryWrapper.distributors(address(s_poolWrapper)));
    }

    function helper_getOracleAnswer() public returns(uint256 oracleAnswer_){
        oracleAnswer_ = s_poolWrapper.getOraclePrice(address(wETH), address(0)) * (10**10);
    }

    function helper_userDeposit(address _user) public returns(uint256 _amountMinted){

        vm.startPrank(_user);
        wETH.approve(address(s_poolWrapper), AMOUNT_TO_DEPOSIT_ON_CREATE);
        _amountMinted = s_poolWrapper.create(
            Pool.TokenType.BOND, 
            AMOUNT_TO_DEPOSIT_ON_CREATE,
            0
        );
        vm.stopPrank();
    }

    function helper_userBids(
        address _user, 
        Auction _auction, 
        uint256 _firstBuyReserveAmount,
        uint256 _firstBidAmount
    ) public {

        vm.startPrank(_user);
        USDC.approve(address(_auction), _firstBidAmount);
        _auction.bid(_firstBuyReserveAmount, _firstBidAmount);
        vm.stopPrank();
    }

    function helper_userClaims(
        address _user,
        Auction _auction,
        uint256 _bidId
    ) public {
        vm.startPrank(_user);
        _auction.claimBid(_bidId);
        vm.stopPrank();
    }

    function helper_commitMoneyForFullTime() public returns(uint256 couponsReceived_){
        /*//////////////////////////////////////
                        DEPOSITS 
        //////////////////////////////////////*/
        //User01 Depositing
        uint256 user01EthBalanceBeforeDepositing = wETH.balanceOf(s_user01);
        uint256 amountMintedForUser01 = helper_userDeposit(s_user01);
        assertEq(wETH.balanceOf(s_user01), user01EthBalanceBeforeDepositing - AMOUNT_TO_DEPOSIT_ON_CREATE);
        assertEq(helper_getOracleAnswer()/10, amountMintedForUser01);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser01);

        //User02 Depositing
        uint256 user02EthBalanceBeforeDepositing = wETH.balanceOf(s_user02);
        uint256 amountMintedForUser02 = helper_userDeposit(s_user02);
        assertEq(wETH.balanceOf(s_user02), user02EthBalanceBeforeDepositing - AMOUNT_TO_DEPOSIT_ON_CREATE);
        assertEq(helper_getOracleAnswer()/10, amountMintedForUser02);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser02 + amountMintedForUser01);

        //User03 Depositing
        uint256 user03EthBalanceBeforeDepositing = wETH.balanceOf(s_user03);
        vm.startPrank(s_user03);
        wETH.approve(address(s_poolWrapper), AMOUNT_TO_DEPOSIT_ON_CREATE);
        uint256 amountMintedForUser03 = s_poolWrapper.create(
            Pool.TokenType.BOND, 
            AMOUNT_TO_DEPOSIT_ON_CREATE - 5*10**18, //Only 5 ether
            0
        );
        vm.stopPrank();
        assertEq(wETH.balanceOf(s_user03), user03EthBalanceBeforeDepositing - 5*10**18);
        assertEq((helper_getOracleAnswer()/10)/2, amountMintedForUser03);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser03 + amountMintedForUser02 + amountMintedForUser01);


        /*//////////////////////////////////////
                        EVERYBODY COMMITS THE MONEY TOGETHER 
        //////////////////////////////////////*/
        //User04 Depositing
        uint256 user04EthBalanceBeforeDepositing = wETH.balanceOf(s_user04);
        vm.startPrank(s_user04);
        wETH.approve(address(s_poolWrapper), AMOUNT_TO_DEPOSIT_ON_CREATE);
        uint256 amountMintedForUser04 = s_poolWrapper.create(
            Pool.TokenType.BOND, 
            4*10**18, //Under the 10% exception
            0
        );
        vm.stopPrank();
        assertEq(wETH.balanceOf(s_user04), user04EthBalanceBeforeDepositing - 4*10**18);
        assertEq(((helper_getOracleAnswer()/10)*40)/100, amountMintedForUser04);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser04 + amountMintedForUser03 + amountMintedForUser02 + amountMintedForUser01);

        /*//////////////////////////////////////
                        PERIOD ENDS
        //////////////////////////////////////*/
        vm.warp(block.timestamp + 25 hours);

        /*//////////////////////////////////////
                        AUCTION IS STARTED
        //////////////////////////////////////*/
        uint256 currentPeriod;
        s_poolWrapper.startAuction();
        (currentPeriod, ) = s_bondWrapper.globalPool();
        Auction firstAuction = Auction(s_poolWrapper.auctions(currentPeriod - 1));
        
        /*//////////////////////////////////////////////////////////////////////////////
                                BIDING STARTS - FIRST AUCTION
        //////////////////////////////////////////////////////////////////////////////*/
        uint256 firstBuyReserveAmount = 2*10**18;
        uint256 firstBidAmount = 4000*10**6;
        address bidder;
        uint256 reserveAmount;
        uint256 sellCouponAmount;

        console.log("User01 Bids");
        helper_userBids(s_user01, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(1);
        assertEq(USDC.balanceOf(s_user01), USDC_INITIAL_AMOUNT - firstBidAmount);
        assertEq(bidder, s_user01);

        console.log("User02 Bids");
        helper_userBids(s_user02, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(2);
        assertEq(USDC.balanceOf(s_user02), USDC_INITIAL_AMOUNT - firstBidAmount);
        assertEq(bidder, s_user02);

        console.log("User03 Bids");
        helper_userBids(s_user03, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(3);
        assertTrue(USDC.balanceOf(s_user03) < USDC_INITIAL_AMOUNT);
        assertEq(bidder, s_user03);

        //Check if storage is correctly updated when an big is reduced
        assertTrue(reserveAmount < firstBuyReserveAmount);
        console.log(reserveAmount);
        assertTrue(sellCouponAmount < firstBidAmount);
        console.log(sellCouponAmount);

        /*//////////////////////////////////////////////////////////////////////////////
                                    FIRST AUCTION - ENDS
        //////////////////////////////////////////////////////////////////////////////*/
        vm.warp(block.timestamp + 16 days);
        firstAuction.endAuction();

        /*//////////////////////////////////////////////////////////////////////////////
                                    FIRST AUCTION - DISTRIBUTE
        //////////////////////////////////////////////////////////////////////////////*/
        uint256 totalBuyCouponAmount = firstAuction.totalBuyCouponAmount(); //should be: 10_202_380_000
        uint256 poolBalanceBefore = USDC.balanceOf(address(s_poolWrapper)); //10_202_380_000
        console.log("Pool Balance Before Distribution:", poolBalanceBefore);
        s_poolWrapper.distribute();
        assertEq(USDC.balanceOf(address(s_poolWrapper)), poolBalanceBefore - totalBuyCouponAmount);

        /*//////////////////////////////////////////////////////////////////////////////
                                    FIRST AUCTION - USERS CLAIM AMOUNTS
        //////////////////////////////////////////////////////////////////////////////*/
        uint256 amountToClaimFromDistributor;
        uint256 distributorBalanceBeforeClaims = USDC.balanceOf(address(s_distributorWrapper));
        console.log("Amount On Distributor to be claimed", distributorBalanceBeforeClaims);

        // User01 Info
        uint256 user1BalanceBeforeClaim = USDC.balanceOf(s_user01);
        amountToClaimFromDistributor = (s_bondWrapper.getIndexedUserAmount(s_user01, s_bondWrapper.balanceOf(s_user01), 1) / 10**12);
        console.log("Amount for User01 to Claim",amountToClaimFromDistributor);
        vm.prank(s_user01);
        s_distributorWrapper.claim();
        assertEq(USDC.balanceOf(s_user01), user1BalanceBeforeClaim + amountToClaimFromDistributor);

        // User02 Info
        uint256 user2BalanceBeforeClaim = USDC.balanceOf(s_user02);
        amountToClaimFromDistributor = (s_bondWrapper.getIndexedUserAmount(s_user02, s_bondWrapper.balanceOf(s_user02), 1) / 10**12);
        console.log("Amount for User02 to Claim",amountToClaimFromDistributor);
        vm.prank(s_user02);
        s_distributorWrapper.claim();
        assertEq(USDC.balanceOf(s_user02), user2BalanceBeforeClaim + amountToClaimFromDistributor);
        
        // User03 Info
        uint256 user3BalanceBeforeClaim = USDC.balanceOf(s_user03);
        amountToClaimFromDistributor = (s_bondWrapper.getIndexedUserAmount(s_user03, s_bondWrapper.balanceOf(s_user03), 1) / 10**12);
        console.log("Amount for User03 to Claim",amountToClaimFromDistributor);
        vm.prank(s_user03);
        s_distributorWrapper.claim();
        assertEq(USDC.balanceOf(s_user03), user3BalanceBeforeClaim + amountToClaimFromDistributor);

        // User04 Info
        uint256 user4BalanceBeforeClaim = USDC.balanceOf(s_user04);
        amountToClaimFromDistributor = (s_bondWrapper.getIndexedUserAmount(s_user04, s_bondWrapper.balanceOf(s_user04), 1) / 10**12);
        console.log("Amount for User04 to Claim",amountToClaimFromDistributor);
        vm.prank(s_user04);
        s_distributorWrapper.claim();
        assertEq(USDC.balanceOf(s_user04), user4BalanceBeforeClaim + amountToClaimFromDistributor);

        couponsReceived_ = amountToClaimFromDistributor;
    }

    function helper_commitMoneyForMinimumPeriodOfTime() public returns(uint256 couponsReceived_){
        
        PoolFactory.PoolParams memory params = PoolFactory.PoolParams({
            fee: 100000,
            reserveToken: address(wETH),
            couponToken: address(USDC),
            distributionPeriod: 10 days,
            sharesPerToken: 10*10**6, //Shares have 10**6 decimals
            feeBeneficiary: s_beneficiary
        });

        vm.startPrank(s_governanceRole);
        //1.
        wETH.approve(address(s_factoryWrapper), WETH_INITIAL_AMOUNT);
        //2.
        s_poolWrapper = Pool(s_factoryWrapper.createPool(
            params,
            RESERVE_INITIAL_AMOUNT,
            BOND_AMOUNT,
            LEV_AMOUNT,
            "BondToken2",
            "BTN2",
            "LeverageToken2",
            "LEVT2",
            false
        ));

        s_poolWrapper.setAuctionPeriod(15 days);

        vm.stopPrank();

        s_bondWrapper = BondToken(address(s_poolWrapper.bondToken()));
        s_levWrapper = LeverageToken(address(s_poolWrapper.lToken()));
        s_distributorWrapper  = Distributor(s_factoryWrapper.distributors(address(s_poolWrapper)));
        /*//////////////////////////////////////
                        DEPOSITS 
        //////////////////////////////////////*/
        //User01 Depositing
        uint256 user01EthBalanceBeforeDepositing = wETH.balanceOf(s_user01);
        uint256 amountMintedForUser01 = helper_userDeposit(s_user01);
        assertEq(wETH.balanceOf(s_user01), user01EthBalanceBeforeDepositing - AMOUNT_TO_DEPOSIT_ON_CREATE);
        assertEq(helper_getOracleAnswer()/10, amountMintedForUser01);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser01);

        //User02 Depositing
        uint256 user02EthBalanceBeforeDepositing = wETH.balanceOf(s_user02);
        uint256 amountMintedForUser02 = helper_userDeposit(s_user02);
        assertEq(wETH.balanceOf(s_user02), user02EthBalanceBeforeDepositing - AMOUNT_TO_DEPOSIT_ON_CREATE);
        assertEq(helper_getOracleAnswer()/10, amountMintedForUser02);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser02 + amountMintedForUser01);

        //User03 Depositing
        uint256 user03EthBalanceBeforeDepositing = wETH.balanceOf(s_user03);
        vm.startPrank(s_user03);
        wETH.approve(address(s_poolWrapper), AMOUNT_TO_DEPOSIT_ON_CREATE);
        uint256 amountMintedForUser03 = s_poolWrapper.create(
            Pool.TokenType.BOND, 
            AMOUNT_TO_DEPOSIT_ON_CREATE - 5*10**18, //Only 5 ether
            0
        );
        vm.stopPrank();
        assertEq(wETH.balanceOf(s_user03), user03EthBalanceBeforeDepositing - 5*10**18);
        assertEq((helper_getOracleAnswer()/10)/2, amountMintedForUser03);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser03 + amountMintedForUser02 + amountMintedForUser01);


        /*//////////////////////////////////////
                        WAITS FOR A CLOSER DATE TO NO COMMIT MONEY TO LONG 
        //////////////////////////////////////*/
        vm.warp(block.timestamp + 14 days + 23 hours);
        
        //User04 Depositing
        uint256 user04EthBalanceBeforeDepositing = wETH.balanceOf(s_user04);
        vm.startPrank(s_user04);
        wETH.approve(address(s_poolWrapper), AMOUNT_TO_DEPOSIT_ON_CREATE);
        uint256 amountMintedForUser04 = s_poolWrapper.create(
            Pool.TokenType.BOND, 
            4*10**18, //Under the 10% exception
            0
        );
        vm.stopPrank();
        assertEq(wETH.balanceOf(s_user04), user04EthBalanceBeforeDepositing - 4*10**18);
        assertEq(((helper_getOracleAnswer()/10)*40)/100, amountMintedForUser04);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser04 + amountMintedForUser03 + amountMintedForUser02 + amountMintedForUser01);

        /*//////////////////////////////////////
                        PERIOD ENDS
        //////////////////////////////////////*/
        vm.warp(block.timestamp + 2 hours);

        /*//////////////////////////////////////
                        AUCTION IS STARTED
        //////////////////////////////////////*/
        uint256 currentPeriod;
        s_poolWrapper.startAuction();
        (currentPeriod, ) = s_bondWrapper.globalPool();
        Auction firstAuction = Auction(s_poolWrapper.auctions(currentPeriod - 1));
        
        /*//////////////////////////////////////////////////////////////////////////////
                                BIDING STARTS - FIRST AUCTION
        //////////////////////////////////////////////////////////////////////////////*/
        uint256 firstBuyReserveAmount = 2*10**18;
        uint256 firstBidAmount = 4000*10**6;
        address bidder;
        uint256 reserveAmount;
        uint256 sellCouponAmount;

        console.log("User01 Bids");
        helper_userBids(s_user01, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(1);
        assertEq(bidder, s_user01);

        console.log("User02 Bids");
        helper_userBids(s_user02, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(2);
        assertEq(bidder, s_user02);

        console.log("User03 Bids");
        helper_userBids(s_user03, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(3);
        assertEq(bidder, s_user03);

        /*//////////////////////////////////////////////////////////////////////////////
                                    FIRST AUCTION - ENDS
        //////////////////////////////////////////////////////////////////////////////*/
        vm.warp(block.timestamp + 16 days);
        firstAuction.endAuction();

        /*//////////////////////////////////////////////////////////////////////////////
                                    FIRST AUCTION - DISTRIBUTE
        //////////////////////////////////////////////////////////////////////////////*/
        uint256 totalBuyCouponAmount = firstAuction.totalBuyCouponAmount(); //should be: 10_202_380_000
        uint256 poolBalanceBefore = USDC.balanceOf(address(s_poolWrapper)); //10_202_380_000
        console.log("Pool Balance Before Distribution:", poolBalanceBefore);
        s_poolWrapper.distribute();
        assertEq(USDC.balanceOf(address(s_poolWrapper)), poolBalanceBefore - totalBuyCouponAmount);

        /*//////////////////////////////////////////////////////////////////////////////
                                    FIRST AUCTION - USERS CLAIM AMOUNTS
        //////////////////////////////////////////////////////////////////////////////*/
        uint256 amountToClaimFromDistributor;
        uint256 distributorBalanceBeforeClaims = USDC.balanceOf(address(s_distributorWrapper));
        console.log("Amount On Distributor to be claimed", distributorBalanceBeforeClaims);

        // User01 Info
        uint256 user1BalanceBeforeClaim = USDC.balanceOf(s_user01);
        amountToClaimFromDistributor = (s_bondWrapper.getIndexedUserAmount(s_user01, s_bondWrapper.balanceOf(s_user01), 1) / 10**12);
        console.log("Amount for User01 to Claim",amountToClaimFromDistributor);
        vm.prank(s_user01);
        s_distributorWrapper.claim();
        assertEq(USDC.balanceOf(s_user01), user1BalanceBeforeClaim + amountToClaimFromDistributor);

        // User02 Info
        uint256 user2BalanceBeforeClaim = USDC.balanceOf(s_user02);
        amountToClaimFromDistributor = (s_bondWrapper.getIndexedUserAmount(s_user02, s_bondWrapper.balanceOf(s_user02), 1) / 10**12);
        console.log("Amount for User02 to Claim",amountToClaimFromDistributor);
        vm.prank(s_user02);
        s_distributorWrapper.claim();
        assertEq(USDC.balanceOf(s_user02), user2BalanceBeforeClaim + amountToClaimFromDistributor);
        
        // User03 Info
        uint256 user3BalanceBeforeClaim = USDC.balanceOf(s_user03);
        amountToClaimFromDistributor = (s_bondWrapper.getIndexedUserAmount(s_user03, s_bondWrapper.balanceOf(s_user03), 1) / 10**12);
        console.log("Amount for User03 to Claim",amountToClaimFromDistributor);
        vm.prank(s_user03);
        s_distributorWrapper.claim();
        assertEq(USDC.balanceOf(s_user03), user3BalanceBeforeClaim + amountToClaimFromDistributor);

        // User04 Info
        uint256 user4BalanceBeforeClaim = USDC.balanceOf(s_user04);
        amountToClaimFromDistributor = (s_bondWrapper.getIndexedUserAmount(s_user04, s_bondWrapper.balanceOf(s_user04), 1) / 10**12);
        console.log("Amount for User4 to Claim",amountToClaimFromDistributor);
        vm.prank(s_user04);
        s_distributorWrapper.claim();
        assertEq(USDC.balanceOf(s_user04), user4BalanceBeforeClaim + amountToClaimFromDistributor);

        couponsReceived_ = amountToClaimFromDistributor;

        /*//////////////////////////////////////
                        REDEEM 
        //////////////////////////////////////*/
        uint256 balanceBeforeWithdraw = wETH.balanceOf(s_user04);
        vm.startPrank(s_user04);
        s_bondWrapper.approve(address(s_poolWrapper), s_bondWrapper.balanceOf(s_user04));
        s_poolWrapper.redeem(Pool.TokenType.BOND, s_bondWrapper.balanceOf(s_user04), 0);
        vm.stopPrank();

        assertTrue(wETH.balanceOf(s_user04) > balanceBeforeWithdraw);
    }
}

```

</details>

PoC

<details>

```solidity

//SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import { Helper } from "./Helper.t.sol";

import { Pool } from "../../src/Pool.sol";
import { Auction } from "../../src/Auction.sol";

import { console } from "forge-std/Console.sol";

contract PoCs is Helper {

    function test_claimFeesBeforeAuction() public {
        /*//////////////////////////////////////
                        DEPOSITS 
        //////////////////////////////////////*/
        //User01 Depositing
        uint256 user01EthBalanceBeforeDepositing = wETH.balanceOf(s_user01);
        uint256 amountMintedForUser01 = helper_userDeposit(s_user01);
        assertEq(wETH.balanceOf(s_user01), user01EthBalanceBeforeDepositing - AMOUNT_TO_DEPOSIT_ON_CREATE);
        assertEq(helper_getOracleAnswer()/10, amountMintedForUser01);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser01);

        //User02 Depositing
        uint256 user02EthBalanceBeforeDepositing = wETH.balanceOf(s_user02);
        uint256 amountMintedForUser02 = helper_userDeposit(s_user02);
        assertEq(wETH.balanceOf(s_user02), user02EthBalanceBeforeDepositing - AMOUNT_TO_DEPOSIT_ON_CREATE);
        assertEq(helper_getOracleAnswer()/10, amountMintedForUser02);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser02 + amountMintedForUser01);

        //User03 Depositing
        uint256 user03EthBalanceBeforeDepositing = wETH.balanceOf(s_user03);
        uint256 amountMintedForUser03 = helper_userDeposit(s_user03);
        assertEq(wETH.balanceOf(s_user03), user03EthBalanceBeforeDepositing - AMOUNT_TO_DEPOSIT_ON_CREATE);
        assertEq((helper_getOracleAnswer()/10), amountMintedForUser03);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser03 + amountMintedForUser02 + amountMintedForUser01);

        /*//////////////////////////////////////
                        PERIOD ENDS
        //////////////////////////////////////*/
        vm.warp(block.timestamp + 90 days + 1);

        /*//////////////////////////////////////
                        AUCTION IS STARTED
        //////////////////////////////////////*/
        uint256 currentPeriod;
        s_poolWrapper.startAuction();
        (currentPeriod, ) = s_bondWrapper.globalPool();
        Auction firstAuction = Auction(s_poolWrapper.auctions(currentPeriod - 1));
        
        /*//////////////////////////////////////////////////////////////////////////////
                                BIDING STARTS - FIRST AUCTION
        //////////////////////////////////////////////////////////////////////////////*/
        uint256 firstBuyReserveAmount = 2*10**18;
        uint256 firstBidAmount = 4000*10**6;
        address bidder;
        uint256 reserveAmount;
        uint256 sellCouponAmount;

        console.log("User01 Bids");
        helper_userBids(s_user01, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(1);
        assertEq(USDC.balanceOf(s_user01), USDC_INITIAL_AMOUNT - firstBidAmount);
        assertEq(bidder, s_user01);

        console.log("User02 Bids");
        helper_userBids(s_user02, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(2);
        assertEq(USDC.balanceOf(s_user02), USDC_INITIAL_AMOUNT - firstBidAmount);
        assertEq(bidder, s_user02);

        console.log("User03 Bids");
        helper_userBids(s_user03, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(3);
        assertTrue(USDC.balanceOf(s_user03) < USDC_INITIAL_AMOUNT);
        assertEq(bidder, s_user03);

        //Check if storage is correctly updated when an big is reduced
        assertTrue(reserveAmount < firstBuyReserveAmount);
        console.log(reserveAmount);
        assertTrue(sellCouponAmount < firstBidAmount);
        console.log(sellCouponAmount);

        /*//////////////////////////////////////
                        PROTOCOL CLAIM FEES
        //////////////////////////////////////*/
        uint256 balanceBeforeClaim = wETH.balanceOf(address(s_poolWrapper));
        console.log("Balance Before Claiming:", balanceBeforeClaim);

        vm.prank(s_beneficiary);
        s_poolWrapper.claimFees();

        uint256 balanceAfterClaim = wETH.balanceOf(address(s_poolWrapper));
        assertEq(wETH.balanceOf(s_beneficiary), balanceBeforeClaim - balanceAfterClaim);

        console.log("Protocol Fee Claimed", balanceBeforeClaim - balanceAfterClaim);

        /*//////////////////////////////////////////////////////////////////////////////
                                    FIRST AUCTION - ENDS
        //////////////////////////////////////////////////////////////////////////////*/
        vm.warp(block.timestamp + 10 days + 1);
        firstAuction.endAuction();
    }

    function test_claimFeesAfterAuction() public {
        /*//////////////////////////////////////
                        DEPOSITS 
        //////////////////////////////////////*/
        //User01 Depositing
        uint256 user01EthBalanceBeforeDepositing = wETH.balanceOf(s_user01);
        uint256 amountMintedForUser01 = helper_userDeposit(s_user01);
        assertEq(wETH.balanceOf(s_user01), user01EthBalanceBeforeDepositing - AMOUNT_TO_DEPOSIT_ON_CREATE);
        assertEq(helper_getOracleAnswer()/10, amountMintedForUser01);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser01);

        //User02 Depositing
        uint256 user02EthBalanceBeforeDepositing = wETH.balanceOf(s_user02);
        uint256 amountMintedForUser02 = helper_userDeposit(s_user02);
        assertEq(wETH.balanceOf(s_user02), user02EthBalanceBeforeDepositing - AMOUNT_TO_DEPOSIT_ON_CREATE);
        assertEq(helper_getOracleAnswer()/10, amountMintedForUser02);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser02 + amountMintedForUser01);

        //User03 Depositing
        uint256 user03EthBalanceBeforeDepositing = wETH.balanceOf(s_user03);
        uint256 amountMintedForUser03 = helper_userDeposit(s_user03);
        assertEq(wETH.balanceOf(s_user03), user03EthBalanceBeforeDepositing - AMOUNT_TO_DEPOSIT_ON_CREATE);
        assertEq((helper_getOracleAnswer()/10), amountMintedForUser03);
        assertEq(s_bondWrapper.totalSupply(), s_bondWrapper.balanceOf(s_governanceRole) + amountMintedForUser03 + amountMintedForUser02 + amountMintedForUser01);

        /*//////////////////////////////////////
                        PERIOD ENDS
        //////////////////////////////////////*/
        vm.warp(block.timestamp + 90 days +1);

        /*//////////////////////////////////////
                        AUCTION IS STARTED
        //////////////////////////////////////*/
        uint256 currentPeriod;
        s_poolWrapper.startAuction();
        (currentPeriod, ) = s_bondWrapper.globalPool();
        Auction firstAuction = Auction(s_poolWrapper.auctions(currentPeriod - 1));
        
        /*//////////////////////////////////////////////////////////////////////////////
                                BIDING STARTS - FIRST AUCTION
        //////////////////////////////////////////////////////////////////////////////*/
        uint256 firstBuyReserveAmount = 2*10**18;
        uint256 firstBidAmount = 4000*10**6;
        address bidder;
        uint256 reserveAmount;
        uint256 sellCouponAmount;

        console.log("User01 Bids");
        helper_userBids(s_user01, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(1);
        assertEq(bidder, s_user01);

        console.log("User02 Bids");
        helper_userBids(s_user02, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(2);
        assertEq(bidder, s_user02);

        console.log("User03 Bids");
        helper_userBids(s_user03, firstAuction, firstBuyReserveAmount, firstBidAmount);
        (bidder,reserveAmount,sellCouponAmount,,,) = firstAuction.bids(3);
        assertEq(bidder, s_user03);

        /*//////////////////////////////////////////////////////////////////////////////
                                    FIRST AUCTION - ENDS
        //////////////////////////////////////////////////////////////////////////////*/
        vm.warp(block.timestamp + 10 days + 1);
        firstAuction.endAuction();

        /*//////////////////////////////////////
                        PROTOCOL CLAIM FEES
        //////////////////////////////////////*/
        uint256 balanceBeforeClaim = wETH.balanceOf(address(s_poolWrapper));
        console.log("Balance Before Claiming:", balanceBeforeClaim);

        vm.prank(s_beneficiary);
        s_poolWrapper.claimFees();

        uint256 balanceAfterClaim = wETH.balanceOf(address(s_poolWrapper));
        assertEq(wETH.balanceOf(s_beneficiary), balanceBeforeClaim - balanceAfterClaim);

        console.log("Protocol Fee Claimed", balanceBeforeClaim - balanceAfterClaim);
    }


```

</details>

### Mitigation

Ensure that the fee claiming occurs before or after an Auction ends to maintain consistency and ensure the right amount of fees is collected.