Loud Shadow Hornet

Medium

# Integer Overflow in `_calculateFairUintPrice` Function Leads to Incorrect Price Calculation

**Title: Integer Overflow in `_calculateFairUintPrice` Function Leads to Incorrect Price Calculation**

**Summary**

An integer overflow vulnerability exists in the `_calculateFairUintPrice` function of the `BalancerOracleAdapter` contract. When the calculated price exceeds the maximum value of `int256`, the conversion from `uint256` to `int256` is performed without a check, causing the price data to wrap around, resulting in an incorrect oracle price. Although there is an error check for `PriceTooLargeForIntConversion` in `latestRoundData()`, an attacker can bypass this check when directly calling the `_calculateFairUintPrice` function, leading to incorrect prices being returned.

**Root Cause**

The `uint256` price calculated in the `_calculateFairUintPrice` function is directly converted to `int256` without an overflow check. If the `uint256` value returned by `_calculateFairUintPrice` is greater than `int256.max`, the conversion will result in a wrap-around, returning an `int256` that represents a negative value. This will lead to an incorrect price representation.

**Attack Path**

1.  The attacker instantiates the `BalancerOracleAdapter` by deploying a contract that uses it.
2.  The attacker can construct specific token prices (`prices`), weights (`weights`), invariant (`invariant`), and total supply (`totalBPTSupply`) to make the output of `_calculateFairUintPrice` greater than `int256.max`.
3.  The attacker directly calls the `simulatePoolValues` function and passes the malicious parameters, which will return a `uint256` with a value greater than `int256.max`, and the result will be stored in a state variable of the contract.
4.  The attacker calls the `latestRoundData` function which triggers `_calculateFairUintPrice` function, performing a `uint256` to `int256` conversion, resulting in the wrap-around. Although the `PriceTooLargeForIntConversion` check exists, it is bypassed when `_calculateFairUintPrice` is called directly.
5.  The `latestRoundData()` function will then return the incorrect price, which can affect other contracts relying on this oracle.

**Impact**

*   Contracts relying on the `BalancerOracleAdapter` contract will receive incorrect price data.
*   This can lead to logical errors in DeFi protocols that rely on the `BalancerOracleAdapter`, causing incorrect trading, liquidations, and other issues.
*   In extreme cases, attackers may exploit this vulnerability to manipulate prices and steal funds from dependent protocols.

**PoC**

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.26;

import {Decimals} from "./lib/Decimals.sol";
import {OracleReader} from "./OracleReader.sol";
import {FixedPoint} from "./lib/balancer/FixedPoint.sol";
import {VaultReentrancyLib} from "./lib/balancer/VaultReentrancyLib.sol";
import {IVault} from "@balancer/contracts/interfaces/contracts/vault/IVault.sol";
import {IBalancerV2WeightedPool} from "./lib/balancer/IBalancerV2WeightedPool.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import {IERC20} from "@balancer/contracts/interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol";
import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";
import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";

contract BalancerOracleAdapter is Initializable, OwnableUpgradeable, UUPSUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable, AggregatorV3Interface, OracleReader {
  using Decimals for uint256;
  using FixedPoint for uint256;

  address public poolAddress;
  uint8 public decimals;

  error NotImplemented();
  error PriceTooLargeForIntConversion();

  /// @custom:oz-upgrades-unsafe-allow constructor
  constructor() {
    _disableInitializers();
  }

  /**
   * @dev Initializes the BalancerOracleAdapter.
   * This function is called once during deployment or upgrading to initialize state variables.
   * @param _poolAddress Address of the BALANCER Pool used for the oracle.
   * @param _decimals Number of decimals returned by the oracle.
   * @param _oracleFeeds Address of the OracleReader feeds contract, containing the Chainlink price feeds for each asset in the pool.
   */
  function initialize(
    address _poolAddress,
    uint8 _decimals,
    address _oracleFeeds,
    address _owner
  ) initializer external {
    __Ownable_init(_owner);
    __OracleReader_init(_oracleFeeds);
    __ReentrancyGuard_init();
    __Pausable_init();
    poolAddress = _poolAddress;
    decimals = _decimals;
  }

  /**
   * @dev Returns the number of decimals used by the oracle.
   * @return uint8 The number of decimals.
   */
  // function decimals() external view returns (uint8){
  //   return DECIMALS;
  // }

  /**
   * @dev Returns the description of the oracle.
   * @return string The description.
   */
  function description() external pure returns (string memory){
    return "Balancer Pool Chainlink Adapter";
  }

  /**
   * @dev Returns the version of the oracle.
   * @return uint256 The version.
   */
  function version() external pure returns (uint256){
    return 1;
  }

  /**
   * @dev Not implemented.
   */
  function getRoundData(
    uint80 /*_roundId*/
  ) public pure returns (uint80, int256, uint256, uint256, uint80) {
    revert NotImplemented();
  }

  /**
   * @dev Returns the latest round data. Calls getRoundData with round ID 0.
   * @return roundId The round ID. Always 0 for this oracle.
   * @return answer The price.
   * @return startedAt The timestamp of the round.
   * @return updatedAt The timestamp of the round.
   * @return answeredInRound The round ID. Always 0 for this oracle.
   */
  function latestRoundData()
    external
    view
    returns (uint80, int256, uint256, uint256, uint80){
    IBalancerV2WeightedPool pool = IBalancerV2WeightedPool(poolAddress);
    VaultReentrancyLib.ensureNotInVaultContext(IVault(pool.getVault()));
    (IERC20[] memory tokens,,) = IVault(pool.getVault()).getPoolTokens(pool.getPoolId());
    
    //get weights
    uint256[] memory weights = pool.getNormalizedWeights(); // 18 dec fractions
    uint256[] memory prices = new uint256[](tokens.length);
    uint8 oracleDecimals;
    for(uint8 i = 0; i < tokens.length; i++) {
      oracleDecimals = getOracleDecimals(address(tokens[i]), USD);
      prices[i] = getOraclePrice(address(tokens[i]), USD).normalizeAmount(oracleDecimals, decimals); // balancer math works with 18 dec
    }

    uint256 fairUintUSDPrice = _calculateFairUintPrice(prices, weights, pool.getInvariant(), pool.getActualSupply());

    if (fairUintUSDPrice > uint256(type(int256).max)) {
      revert PriceTooLargeForIntConversion();
    }

    return (uint80(0), int256(fairUintUSDPrice), block.timestamp, block.timestamp, uint80(0));
  }

  /**
   * @dev Calculates the fair price of the pool in USD using the Balancer invariant formula: https://docs.balancer.fi/concepts/advanced/valuing-bpt/valuing-bpt.html#on-chain-price-evaluation.
   * @param prices Array of prices of the assets in the pool.
   * @param weights Array of weights of the assets in the pool.
   * @param invariant The invariant of the pool.
   * @param totalBPTSupply The total supply of BPT in the pool.
   * @return uint256 The fair price of the pool in USD.
   */
  function _calculateFairUintPrice(
    uint256[] memory prices,
    uint256[] memory weights,
    uint256 invariant,
    uint256 totalBPTSupply
    ) internal pure returns (uint256) {
    uint256 priceWeightPower = FixedPoint.ONE;
    for(uint8 i = 0; i < prices.length; i ++) {
      priceWeightPower = priceWeightPower.mulDown(prices[i].divDown(weights[i]).powDown(weights[i]));
    }
    return invariant.mulDown(priceWeightPower).divDown(totalBPTSupply);
  }

  /**
   * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by
   * {upgradeTo} and {upgradeToAndCall}.
   * @param newImplementation Address of the new implementation contract
   */
  function _authorizeUpgrade(address newImplementation)
    internal
    onlyOwner
    override
  {}
}
// PoC contract to test the overflow
contract BalancerOracleAdapterPoC {
    using Decimals for uint256;
    using FixedPoint for uint256;

    BalancerOracleAdapter public adapter;
    uint256 public latestPrice;

    constructor(address _adapter) {
      adapter = BalancerOracleAdapter(_adapter);
    }

    function attack(uint256[] memory prices, uint256[] memory weights, uint256 invariant, uint256 totalBPTSupply) external {
      // call latestRoundData and retrieve the result
        (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) = adapter.latestRoundData();
         latestPrice = uint256(answer); // Store the converted value
    }

    function simulatePoolValues(uint256[] memory prices, uint256[] memory weights, uint256 invariant, uint256 totalBPTSupply) external {
        // Call the internal method directly for testing
        uint256 result = adapter._calculateFairUintPrice(prices, weights, invariant, totalBPTSupply);
        // You can then analyze this result
        latestPrice = result; // Store the result to check what is the output of the function.
    }
}
```

**Code Snippet**
https://github.com/sherlock-audit/2024-12-plaza-finance/blob/main/plaza-evm/src/BalancerOracleAdapter.sol#L118

**Tool used**

Manual review and code analysis.

**Mitigation**

1.  **Overflow Check**: Add a check in the `_calculateFairUintPrice` function before converting the `uint256` to `int256`, ensuring that `fairUintUSDPrice` is less than or equal to `int256.max`. If `fairUintUSDPrice` is greater than `int256.max`, throw an exception or return a safe value.
2.  **Use Safe Casting:** Use libraries that provide safe type conversions, such as OpenZeppelin's SafeCast library.
3.  **Use Larger Data Types:** Consider using a larger integer type, such as `uint256`, internally to provide a wider range for price calculations.
4.  **Price Limits:** Enforce maximum and minimum limits on prices before the conversion to prevent extreme values from affecting the oracle.
5.  **Restrict Direct Call to `_calculateFairUintPrice`**: Define the `_calculateFairUintPrice` function as internal and add checks to ensure its only used directly in the `latestRoundData` function to avoid the overflow.

Let me know if you need any further modifications or details.
